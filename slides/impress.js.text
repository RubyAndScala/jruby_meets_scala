title: JRuby meets Scala | Not even a compiler can separate us
author: Martin Mauch


%%%%%
%% Add some inline style rules...

%css

a {
  color: #41a9ff;
  text-decoration: underline;
}

body {
  background-image: -webkit-linear-gradient(top left, black, white);
  background-image:    -moz-linear-gradient(top left, black, white);
  background-image:     -ms-linear-gradient(top left, black, white);
  background-image:      -o-linear-gradient(top left, black, white);
  background-image:         linear-gradient(top left, black, white);
}

.impress-enabled .step {
  width: 1000px;
  height: 600px;
  padding: 40px 60px;
  font-size: 30px;
  text-shadow: 5px 5px 12px rgba(0,0,0,0.2);

  margin: 10;
  opacity: 0.1;
  border-style:solid;
  border-color:red;
  border-radius: 60px;
  -webkit-transition: opacity 2s;
  -moz-transition:    opacity 2s;
  -ms-transition:     opacity 2s;
  -o-transition:      opacity 2s;
  transition:         opacity 2s;
}

.impress-enabled .step.active { opacity: 1 }


.slide h2 {
  font-family: 'Helvetica Neue', Helvetica, sans-serif;
  font-weight: 100;
  font-size: 48px;
  text-align: center;
  text-shadow: 10px 10px 24px rgba(0,0,0,0.5);
}

.step.active {
  opacity: 1;
}

.slide {
  background: white;
}

.step.slide.transparent.future {
  opacity: 0.0;
}

.step.slide.transparent.past {
  opacity: 0.0;
}

.step.slide.omnipresent {
  opacity: 1.0;
}

.slide p,
.slide li {
  font-weight: bold;
  letter-spacing: -.03em;
}
  
.slide > ul {
  list-style:none;  
}

.slide ol {
  margin-left:2em;  
}
  
.slide > ul ul {
  margin-left:2em;  
  list-style: none;
}

.slide li li {
  font-size:80%;
}
  
.slide li {
  margin:1.0em 0;
}

.slide > ul > li:before {
  content:'\2714';
  color: #a0c12c;
  padding-right: .5em;
}
    
.slide li li:before {
  content: '\279C';
  color: #41a9ff;
  padding-right: .2em;
}

code {
  background-color: yellow;
  font-size: 14px;
}

blockquote {
  font: 24px/30px italic Times, serif;
  padding: 8px;
  background-color: #faebbc;
  border-top: 1px solid #e1cc89;
  border-bottom: 1px solid #e1cc89;
  margin: 5px;
  background-image: url(img/openquote1.gif);
  background-position: top left;
  background-repeat: no-repeat;
  text-indent: 23px;
  }
  blockquote p {
      display: block;
      background-image: url(img/closequote1.gif);
      background-repeat: no-repeat;
      background-position: bottom right;
    }
%end


%%%%%%%%%%%%%%%%%%%
%% Here we go...


!SLIDE slide omnipresent x=0 y=0 scale=5

<div id="myinnercontainer" style="position:absolute; top:50%; right:50%; height:10em; margin-top:-6em; margin-right:-10.5em">
  <h2>JRuby <img src="img/ruby_logo.svg" width="60" height="60"/>&nbsp;
  <span style="display:inline-block;vertical-align:middle">
  <img src="img/arrow_curved_blue.svg" width="210" height="105"/><br/>
  <img src="img/arrow_curved_blue.svg" width="210" height="105" style="-webkit-transform:rotate(180deg);transform:rotate(180deg);"/>
  </span>&nbsp;
  Scala <img src="img/scala_logo.svg" width="60" height="100"/>
  </h2>
</div>


!SLIDE slide x=-1180 y=400
Why Ruby?
---------

 * [Rails](http://rubyonrails.org/)
 * Expressiveness
 * [Ruby philosophy](http://en.wikipedia.org/wiki/Ruby_(programming_language)#Philosophy)

> Often people, especially computer engineers, focus on the machines.
> They think, "By doing this, the machine will run faster. By doing this, the machine will run more effectively. By doing this, the machine will something something something."
> They are focusing on machines.
> But in fact we need to focus on humans, on how humans care about doing programming or operating the application of the machines.
> We are the masters. They are the slaves.


!SLIDE slide x=1180 y=400
Why Scala?
----------

 * [Reactive](http://www.reactivemanifesto.org/) [Web](http://spray.io/) [Frameworks](http://www.playframework.com/)
 * [Akka Actor Framework](http://akka.io/)
 * Expressiveness
 * [Type Safety](http://www.slideshare.net/dgalichet/demystifying-scala-type-system), [Type Inference](http://docs.scala-lang.org/tutorials/tour/local-type-inference.html), [Macro tricks](http://scalamacros.org/)
 * [Performance](http://benchmarksgame.alioth.debian.org/u64q/benchmark.php?test=all&lang=jruby&lang2=scala&data=u64q#faster-programs-measurements)

Learn more at [scala-tour.com](http://www.scala-tour.com/)

!SLIDE slide x=0 y=800 scale=0.7
Similarities
-------------

 * Syntax
 * Collection library
 * DSL capabilities
 * Code reuse via modules/traits

!SLIDE slide x=0 y=1350 scale=0.7
Differences
-------------

 * Learning curve
   * Ruby: Just try it
   * Scala: Obey the compiler
 * Functional programming
   * Ruby: 2nd class citizen
   * Scala: 1.2nd class citizen


!SLIDE slide transparent x=0 y=0 scale=5 z=-1

!SLIDE slide x=0 y=-110 scale=0.4
Tooling
-------

 * sbt
   * continuously compiles Scala code
   * writes .classpath file
   * packages .jar for gem
 * scala_helper.rb
   * Loads .class and .jar files from .classpath
 * guard
   * picks up changes in Ruby and .class files

!SLIDE slide x=0 y=-550 scale=0.4
JRuby → Scala
-------------

 * [jruby-scala-collections](https://github.com/RubyAndScala/jruby-scala-collections)



!SLIDE slide x=0 y=330 scale=0.4
Scala → JRuby
-------------

 * [Scuby](https://github.com/mcamou/scuby)
 * [jruby-scala-collections](https://github.com/RubyAndScala/jruby-scala-collections)



!SLIDE slide transparent x=0 y=0 z=30 scale=10
Learnings
---------

 * It's easier to make JRuby compatible with Scala
 * Many roads pass by Java
 * Real fun starts when JRuby and Scala interact directly
 * Collection interop is biggest pain-point

!SLIDE slide x=1180 y=1200 scale=1
In Scala, how do you...
-----------------------

 * Add functionality to existing classes?
   * Implicits (Pimp-my-library pattern)
 * Create DSLs?
   * Implicits
   * Macros
 * Achieve scalability
   * Parallel collections
   * Actors


%% The End
%%%%%%%%%%%%%%%